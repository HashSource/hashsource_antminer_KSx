//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <errno.h>
#include <netdb.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float128_t;

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct hostent {
    char *e0;
    char **e1;
    int32_t e2;
    int32_t e3;
    char **e4;
};

struct sockaddr {
    int32_t e0;
    char e1[14];
};

// ------------------- Function Prototypes --------------------

int32_t __libc_csu_fini(void);
int32_t __libc_csu_init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t _fini(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t _init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t _start(int32_t i_a1, int32_t i_a2);
int32_t callapi(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t display(int32_t i_a1);
int32_t function_10908(char *s1, char *s2);
int32_t function_10914(char *nptr, char **endptr, int32_t base);
int32_t function_10920(int32_t fd, int32_t level, int32_t optname,
                       int32_t *optval, int32_t optlen);
int32_t function_1092c(char *format, ...);
void function_10938(int32_t *ptr);
int32_t *function_10944(int32_t *ptr, int32_t size);
int32_t *function_10950(int32_t *s, int32_t c);
int32_t function_1095c(char *s);
int32_t *function_10968(int32_t size);
int32_t function_10974(int32_t main2, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)());
char *function_10980(int32_t errnum);
void function_1098c(void);
int16_t **function_10998(void);
int32_t function_109a4(char *s);
char *function_109b0(char *s, int32_t c);
int32_t function_109bc(struct _IO_FILE *stream, char *format, ...);
int32_t *function_109c8(void);
int32_t function_109d4(int32_t domain, int32_t type, int32_t protocol);
struct hostent *function_109e0(char *name);
void function_109ec(void);
int32_t function_109f8(int32_t fd, int32_t *buf, int32_t n, int32_t flags);
int32_t function_10a04(int32_t fd);
int32_t function_10a10(int32_t fd, int32_t *buf, int32_t n, int32_t flags);
int32_t function_10a1c(int32_t fd, struct sockaddr *addr, int32_t len);
int32_t function_10be0(int32_t i_a1, int32_t i_a2, int32_t i_a3);
int32_t function_10bec(void);
int32_t function_10c10(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4);
int32_t function_10c6c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5);
int32_t function_10c78(void);
int32_t function_10c7c(int32_t i_a1);
int32_t unknown_240(void);

// --------------------- Global Variables ---------------------

int32_t i_g1 = -0x1cae0000;   // 0x10bfc
char *p_g2;                   // 0x112b8
int32_t i_g3 = 0x10c79;       // 0x21f08
struct _IO_FILE *p_g4 = NULL; // 0x22078
int32_t i_g5 = 0;             // 0x22080
int32_t i_g6;

// ------- Dynamically Linked Functions Without Header --------

void __gmon_start__(void);
int32_t __libc_start_main(int32_t i_a1, int32_t i_a2, char **p_a3,
                          void (*p_a4)(), void (*p_a5)(), void (*p_a6)());
int32_t *__rawmemchr(int32_t *p_a1, int32_t i_a2);

// ------------------------ Functions -------------------------

// Address range: 0x108e8 - 0x108f4
int32_t _init(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x108e8
    return function_10bec();
}

// Address range: 0x10908 - 0x10914
int32_t function_10908(char *s1, char *s2) {
    // 0x10908
    return strcmp(s1, s2);
}

// Address range: 0x10914 - 0x10920
int32_t function_10914(char *nptr, char **endptr, int32_t base) {
    // 0x10914
    return strtol(nptr, endptr, base);
}

// Address range: 0x10920 - 0x1092c
int32_t function_10920(int32_t fd, int32_t level, int32_t optname,
                       int32_t *optval, int32_t optlen) {
    // 0x10920
    return setsockopt(fd, level, optname, optval, optlen);
}

// Address range: 0x1092c - 0x10938
int32_t function_1092c(char *format, ...) {
    // 0x1092c
    return printf(format);
}

// Address range: 0x10938 - 0x10944
void function_10938(int32_t *ptr) {
    // 0x10938
    free(ptr);
}

// Address range: 0x10944 - 0x10950
int32_t *function_10944(int32_t *ptr, int32_t size) {
    // 0x10944
    return realloc(ptr, size);
}

// Address range: 0x10950 - 0x1095c
int32_t *function_10950(int32_t *s, int32_t c) {
    // 0x10950
    return __rawmemchr(s, c);
}

// Address range: 0x1095c - 0x10968
int32_t function_1095c(char *s) {
    // 0x1095c
    return puts(s);
}

// Address range: 0x10968 - 0x10974
int32_t *function_10968(int32_t size) {
    // 0x10968
    return malloc(size);
}

// Address range: 0x10974 - 0x10980
int32_t function_10974(int32_t main2, int32_t argc, char **ubp_av,
                       void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x10974
    return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x10980 - 0x1098c
char *function_10980(int32_t errnum) {
    // 0x10980
    return strerror(errnum);
}

// Address range: 0x1098c - 0x10998
void function_1098c(void) {
    // 0x1098c
    __gmon_start__();
}

// Address range: 0x10998 - 0x109a4
int16_t **function_10998(void) {
    // 0x10998
    return __ctype_b_loc();
}

// Address range: 0x109a4 - 0x109b0
int32_t function_109a4(char *s) {
    // 0x109a4
    return strlen(s);
}

// Address range: 0x109b0 - 0x109bc
char *function_109b0(char *s, int32_t c) {
    // 0x109b0
    return strchr(s, c);
}

// Address range: 0x109bc - 0x109c8
int32_t function_109bc(struct _IO_FILE *stream, char *format, ...) {
    // 0x109bc
    return fprintf(stream, format);
}

// Address range: 0x109c8 - 0x109d4
int32_t *function_109c8(void) {
    // 0x109c8
    return __errno_location();
}

// Address range: 0x109d4 - 0x109e0
int32_t function_109d4(int32_t domain, int32_t type, int32_t protocol) {
    // 0x109d4
    return socket(domain, type, protocol);
}

// Address range: 0x109e0 - 0x109ec
struct hostent *function_109e0(char *name) {
    // 0x109e0
    return gethostbyname(name);
}

// Address range: 0x109ec - 0x109f8
void function_109ec(void) {
    // 0x109ec
    abort();
}

// Address range: 0x109f8 - 0x10a04
int32_t function_109f8(int32_t fd, int32_t *buf, int32_t n, int32_t flags) {
    // 0x109f8
    return recv(fd, buf, n, flags);
}

// Address range: 0x10a04 - 0x10a10
int32_t function_10a04(int32_t fd) {
    // 0x10a04
    return close(fd);
}

// Address range: 0x10a10 - 0x10a1c
int32_t function_10a10(int32_t fd, int32_t *buf, int32_t n, int32_t flags) {
    // 0x10a10
    return send(fd, buf, n, flags);
}

// Address range: 0x10a1c - 0x10a28
int32_t function_10a1c(int32_t fd, struct sockaddr *addr, int32_t len) {
    // 0x10a1c
    return connect(fd, addr, len);
}

// Address range: 0x10a28 - 0x10bbc
int main(int argc, char **argv) {
    // 0x10a28
    if (argc < 2) {
        // 0x10b50
        return callapi((int32_t) "summary", (int32_t) "127.0.0.1", 4028);
    }
    int32_t i_v1 = (int32_t)argv;
    int32_t i_v2 = *(int32_t *)(i_v1 + 4); // 0x10a34
    char *p_v3 = (char *)i_v2;             // 0x10a40
    char i_v4;                             // 0x10adc
    if (*p_v3 == 45) {
        // 0x10adc
        i_v4 = *(char *)(i_v2 + 1);
        switch (i_v4) {
        case 63: {
            // 0x10ae8
            if (*(char *)(i_v2 + 2) == 0) {
                // 0x10b74
                fprintf(p_g4, "usAge: %s [command [ip/host [port]]]\n",
                        (char *)i_v1);
                return 1;
            }
            goto lab_0x10af4;
        }
        case 104: {
            // 0x10b68
            if (*(char *)(i_v2 + 2) == 0) {
                // 0x10b74
            }
            goto lab_0x10a4c;
        }
        default: {
            goto lab_0x10af4;
        }
        }
    } else {
        goto lab_0x10a4c;
    }
lab_0x10a4c:;
    int32_t i_v5 = 1; // 0x10a60
    if (strcmp(p_v3, "--help") == 0) {
        // 0x10b74
        fprintf(p_g4, "usAge: %s [command [ip/host [port]]]\n",
                (char *)(int32_t) "--help");
        return 1;
    }
    goto lab_0x10a68;
lab_0x10af4:
    // 0x10af4
    if (strcmp(p_v3, "--help") == 0) {
        // 0x10b74
        fprintf(p_g4, "usAge: %s [command [ip/host [port]]]\n",
                (char *)(int32_t) "--help");
        return 1;
    }
    // 0x10b0c
    i_v5 = 1;
    if (i_v4 == 111) {
        // 0x10b14
        i_v5 = 1;
        if (*(char *)(i_v2 + 2) == 0) {
            // 0x10b20
            i_g5 = 1;
            i_v5 = 2;
            if (argc == 2) {
                // 0x10b50
                return callapi((int32_t) "summary", (int32_t) "127.0.0.1",
                               4028);
            }
        }
    }
    goto lab_0x10a68;
lab_0x10a68:;
    int32_t i_v6 = 4 * i_v5 + i_v1;                  // 0x10a68
    int32_t i_v7 = function_10c7c(*(int32_t *)i_v6); // 0x10a70
    int32_t i_v8 = *(char *)i_v7 == 0 ? (int32_t) "summary" : i_v7;
    if (i_v5 + 1 >= argc) {
        // 0x10b50
        return callapi(i_v8, (int32_t) "127.0.0.1", 4028);
    }
    int32_t i_v9 = function_10c7c(*(int32_t *)(i_v6 + 4)); // 0x10aa8
    int32_t i_v10 = *(char *)i_v9 == 0 ? (int32_t) "127.0.0.1" : i_v9;
    if (i_v5 + 2 >= argc) {
        // 0x10b50
        return callapi(i_v8, i_v10, 4028);
    }
    char *p_v11 = (char *)function_10c7c(*(int32_t *)(i_v6 + 8)); // 0x10ac8
    int32_t i_v12 = 4028;                                         // 0x10ad0
    if (*p_v11 != 0) {
        // 0x10b98
        i_v12 = __asm_sxth(strtol(p_v11, NULL, 10));
    }
    // 0x10b50
    return callapi(i_v8, i_v10, i_v12);
}

// Address range: 0x10bbc - 0x10be0
int32_t _start(int32_t i_a1, int32_t i_a2) {
    // 0x10bbc
    int32_t i_v1; // 0x10bbc
    __libc_start_main(0x10a28, i_a2, (char **)&i_v1, (void (*)())0x11215,
                      (void (*)())0x10a28, (void (*)())i_a1);
    abort();
    // UNREACHABLE
}

// Address range: 0x10be0 - 0x10be4
int32_t function_10be0(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    // 0x10be0
    return i_a1;
}

// Address range: 0x10bec - 0x10c08
int32_t function_10bec(void) {
    int32_t i_v1 =
        *(int32_t *)((int32_t)&i_g1 + (int32_t) " server close the socket" +
                     108); // 0x10bf8
    if (i_v1 == 0) {
        int32_t i_v2; // 0x10bec
        return i_v2;
    }
    // 0x10c04
    __gmon_start__();
    return &i_g6;
}

// Address range: 0x10c10 - 0x10c6c
int32_t function_10c10(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x10c10
    bool i_v1; // 0x10c10
    if (i_v1) {
        return i_a1;
    }
    // 0x10c40
    int32_t i_v2;                   // 0x10c10
    int32_t i_v3 = 0x100001 * i_v2; // 0x10c44
    bool i_v4;                      // 0x10c10
    int32_t i_v5;                   // 0x10c10
    if (i_v1) {
        // .thread
        i_v5 = i_v1 ? i_v3 : 0;
    } else {
        int32_t i_v6 = i_v3 & -1 - 0x400000 * i_v2; // 0x10c48
        i_v5 = i_v6 < 1 ? 0 : i_v3;
        i_v4 = i_v6 < 0;
        if (i_v6 == 0) {
            return unknown_240();
        }
    }
    // 0x10c58
    if (i_v4 != i_v1) {
        __asm_svclt(0x4770);
    }
    float64_t f_v7; // 0x10c10
    __asm_vqrshl_s8(f_v7, f_v7);
    __asm_vmvn_i32(0xc0000);
    if (!i_v1) {
        *(int32_t *)i_a4 = i_v5;
    }
    return i_a1;
}

// Address range: 0x10c6c - 0x10c78
int32_t function_10c6c(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4,
                       int32_t i_a5) {
    int32_t i_v1 = i_a1; // 0x10c6c
    if (i_a4 == 0) {
        // 0x10c6e
        i_v1 = function_10c10(i_a1, i_a2, i_a3, 0);
        int32_t i_v2; // 0x10c6c
        *(char *)i_v2 = 1;
    }
    // 0x10c76
    return i_v1;
}

// Address range: 0x10c78 - 0x10c7a
int32_t function_10c78(void) {
    // 0x10c78
    int32_t i_v1; // 0x10c78
    return i_v1;
}

// Address range: 0x10c7c - 0x10cec
int32_t function_10c7c(int32_t i_a1) {
    int16_t **p_v1 = __ctype_b_loc(); // 0x10c84
    int32_t i_v2 = (int32_t)*p_v1;    // 0x10c8c
    uint32_t i_v3 = i_a1;             // 0x10c90
    while ((*(int16_t *)(2 * (int32_t) * (char *)i_v3 + i_v2) & 0x2000) != 0) {
        // 0x10c94
        i_v3++;
    }
    int32_t i_v4 = (int32_t)__rawmemchr((int32_t *)i_v3, 0); // 0x10cb8
    if (i_v3 >= i_v4) {
        // 0x10ce4
        return i_v3;
    }
    int32_t i_v5 = i_v4; // 0x10cc4
    i_v5--;
    char *p_v6 = (char *)i_v5; // 0x10cc4
    if ((*(int16_t *)(2 * (int32_t)*p_v6 + (int32_t)*p_v1) & 0x2000) != 0) {
        *p_v6 = 0;
    }
    while (i_v3 < i_v5) {
        // 0x10cc4
        i_v5--;
        p_v6 = (char *)i_v5;
        if ((*(int16_t *)(2 * (int32_t)*p_v6 + (int32_t)*p_v1) & 0x2000) != 0) {
            *p_v6 = 0;
        }
    }
    // 0x10ce4
    return i_v3;
}

// Address range: 0x10cec - 0x10e78
int32_t display(int32_t i_a1) {
    // 0x10cec
    if (i_a1 == 0) {
        // 0x10d50
        return 0;
    }
    int32_t i_v1 = i_a1; // 0x10cf8
    int32_t i_v2;        // 0x10cec
    int32_t i_v3;        // 0x10cec
    int32_t i_v4;        // 0x10cec
    int32_t i_v5;        // 0x10cec
    int32_t i_v6;        // 0x10cec
    while (true) {
    lab_0x10d18:
        // 0x10d18
        i_v4 = i_v1;
        char *p_v7 = (char *)i_v4;      // 0x10d20
        char *p_v8 = strchr(p_v7, 124); // 0x10d20
        int32_t i_v9 = (int32_t)p_v8;   // 0x10d20
        if (p_v8 == NULL) {
            // 0x10d58
            i_v3 = i_v9;
            i_v6 = i_v9;
            if (*p_v7 == 0) {
                // break -> 0x10d50
                break;
            }
            goto lab_0x10d64;
        } else {
            // 0x10d2c
            *p_v8 = 0;
            int32_t i_v10 = i_v9 + 1; // 0x10d38
            i_v2 = i_v9;
            i_v5 = i_v10;
            i_v6 = i_v10;
            if (*p_v7 == 0) {
                goto lab_0x10d48;
            } else {
                goto lab_0x10d64;
            }
        }
    }
lab_0x10d50:
    // 0x10d50
    return i_v3;
lab_0x10d88:;
    // 0x10d88
    int32_t i_v11; // 0x10cec
    int32_t i_v12 = i_v11;
    char *p_v13;                     // 0x10cec
    char *p_v14 = strchr(p_v13, 61); // 0x10d90
    char *p_v15;                     // 0x10cec
    int32_t i_v16;                   // 0x10cec
    int32_t i_v17;                   // 0x10cec
    if (p_v14 == NULL) {
        if (i_v17 == 0) {
            // 0x10e64
            printf("[%s%s] =>\n(\n", p_v13, (char *)&p_g2);
            // 0x10e44
            printf("   [%d] => %s\n", i_v17, p_v13);
            i_v16 = i_v12;
            goto lab_0x10dfc;
        } else {
            // 0x10e44
            printf("   [%d] => %s\n", i_v17, p_v13);
            i_v16 = i_v12;
            goto lab_0x10dfc;
        }
    } else {
        int32_t i_v18 = (int32_t)p_v14 + 1; // 0x10da4
        *p_v14 = 0;
        if (i_v17 == 0) {
            if (i_v18 == 0) {
                // 0x10e64
                printf("[%s%s] =>\n(\n", p_v13, (char *)&p_g2);
                // 0x10e44
                printf("   [%d] => %s\n", i_v17, p_v13);
                i_v16 = i_v12;
                goto lab_0x10dfc;
            } else {
                int16_t **p_v19 = __ctype_b_loc(); // 0x10db8
                char *p_v20 = (char *)i_v18;
                int16_t i_v21 = *(int16_t *)(2 * (int32_t)*p_v20 +
                                             (int32_t)*p_v19); // 0x10dd0
                printf("[%s%s] =>\n(\n", p_v13,
                       (i_v21 & 2048) == 0 ? (char *)&p_g2 : p_v20);
                p_v15 = p_v20;
                goto lab_0x10de4;
            }
        } else {
            if (i_v18 == 0) {
                // 0x10e44
                printf("   [%d] => %s\n", i_v17, p_v13);
                i_v16 = i_v12;
                goto lab_0x10dfc;
            } else {
                // 0x10e3c
                p_v15 = (char *)i_v18;
                goto lab_0x10de4;
            }
        }
    }
lab_0x10dfc:;
    int32_t i_v22 = i_v16;     // 0x10e04
    int32_t i_v23 = i_v17 + 1; // 0x10e04
    if (i_v16 == 0) {
        // break -> 0x10e28
        goto lab_0x10e28;
    }
    goto lab_0x10e08;
lab_0x10de4:
    // 0x10de4
    printf("   [%s] => %s\n", p_v13, p_v15);
    i_v16 = i_v12;
    goto lab_0x10dfc;
lab_0x10d64:
    // 0x10d64
    i_v22 = i_v4;
    i_v23 = 0;
    while (true) {
    lab_0x10e08:
        // 0x10e08
        i_v17 = i_v23;
        p_v13 = (char *)i_v22;
        char *p_v24 = strchr(p_v13, 44); // 0x10e10
        int32_t i_v25 = (int32_t)p_v24;  // 0x10e10
        if (p_v24 == NULL) {
            // 0x10e1c
            i_v11 = i_v25;
            if (*p_v13 == 0) {
                // break -> 0x10e28
                break;
            }
            goto lab_0x10d88;
        } else {
            // 0x10d6c
            *p_v24 = 0;
            int32_t i_v26 = i_v25 + 1; // 0x10d78
            i_v11 = i_v26;
            i_v16 = i_v26;
            if (*p_v13 == 0) {
                goto lab_0x10dfc;
            } else {
                goto lab_0x10d88;
            }
        }
    }
lab_0x10e28:
    // 0x10e28
    i_v2 = puts(")");
    i_v5 = i_v6;
    goto lab_0x10d48;
lab_0x10d48:
    // 0x10d48
    i_v1 = i_v5;
    i_v3 = i_v2;
    if (i_v1 == 0) {
        // break -> 0x10d50
        goto lab_0x10d50;
    }
    goto lab_0x10d18;
}

// Address range: 0x10e78 - 0x11214
int32_t callapi(int32_t i_a1, int32_t i_a2, int32_t i_a3) {
    char *p_v1 = (char *)i_a2; // 0x10e90
    if (gethostbyname(p_v1) == NULL) {
        // 0x10fd4
        printf("Couldn't get hostname: '%s'\n", p_v1);
        return 1;
    }
    int32_t i_v2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x10ea8
    if (i_v2 == -1) {
        // 0x10ff4
        printf("Socket initialisation failed: %s\n",
               strerror(*__errno_location()));
        return 1;
    }
    float64_t f_v3 = __asm_vmov_i32(0); // 0x10eb8
    __asm_rev16(i_a3);
    int32_t i_v4; // 0x10e78
    __asm_vst1_8(f_v3, i_v4);
    int32_t i_v5 = 2; // bp-56, 0x10ed8
    __asm_vst1_8(f_v3, i_v4);
    if (connect(i_v2, (struct sockaddr *)&i_v5, 16) < 0) {
        // 0x11020
        printf("Socket connect failed: %s\n", strerror(*__errno_location()));
        return 1;
    }
    int32_t i_v6 = 1; // bp-72, 0x10f20
    if (setsockopt(i_v2, SO_DEBUG, 13, &i_v6, 8) != 0) {
        // 0x1109c
        printf("cgminer-api, setsocket SO_LINGER failed (%s)\n",
               strerror(*__errno_location()));
        close(i_v2);
    }
    int32_t i_v7 = 10; // bp-64, 0x10f58
    if (setsockopt(i_v2, SO_DEBUG, 21, &i_v7, 8) != 0) {
        // 0x11074
        printf("cgminer-api, setsocket SO_SNDTIMEO failed (%s)\n",
               strerror(*__errno_location()));
        close(i_v2);
    }
    int32_t i_v8 = setsockopt(i_v2, SO_DEBUG, 20, &i_v7, 8); // 0x10f80
    if (i_v8 != 0) {
        // 0x1104c
        printf("cgminer-api, setsocket SO_RCVTIMEO failed (%s)\n",
               strerror(*__errno_location()));
        close(i_v2);
    }
    char *p_v9 = (char *)i_a1;                                    // 0x10f90
    int32_t i_v10 = send(i_v2, (int32_t *)i_a1, strlen(p_v9), 0); // 0x10fa4
    if (i_v10 < 1) {
        // 0x110c4
        printf("cgminer api send failed: %s\n", strerror(*__errno_location()));
        // 0x10fc0
        close(i_v2);
        // 0x10fc8
        return 1;
    }
    // 0x10fb0
    if (strlen(p_v9) != i_v10) {
        // 0x10fc0
        close(i_v2);
        // 0x10fc8
        return i_v8;
    }
    int32_t *p_v11 = malloc(0x10000); // 0x110ec
    int32_t i_v12 = 0xffff;           // 0x11100
    int32_t i_v13 = 3;                // 0x11100
    if (p_v11 == NULL) {
        // 0x11180
        printf("cgminer api: OOM (%d)\n", 0x10000);
    lab_0x10fc8:
        // 0x10fc8
        return 1;
    }
    int32_t *p_v14 = p_v11;
    int32_t i_v15 = 0;
    int32_t i_v16 = (int32_t)p_v14;
    int32_t i_v17 = i_v15 + i_v16;                           // 0x11104
    int32_t i_v18 = recv(i_v2, (int32_t *)i_v17, 0xffff, 0); // 0x1111c
    int32_t i_v19;                                           // 0x10e78
    int32_t i_v20;                                           // 0x10e78
    while (i_v18 >= 0) {
        if (i_v18 == 0) {
            // 0x111f8
            puts("Recv failed: api server close the socket");
            i_v19 = 1;
            i_v20 = i_v17;
            goto lab_0x1119c;
        }
        int32_t i_v21 = i_v12;
        int32_t i_v22 = i_v18 + i_v15; // 0x11134
        if (i_v21 != i_v22) {
            // 0x1120c
            i_v19 = i_v8;
            i_v20 = i_v22 + i_v16;
            goto lab_0x1119c;
        }
        // 0x11148
        if (i_v13 == 1) {
            // 0x11198
            i_v19 = i_v8;
            i_v20 = i_v21 + i_v16;
            goto lab_0x1119c;
        }
        int32_t i_v23 = i_v21 + 0x10000;        // 0x11118
        int32_t *p_v24 = realloc(p_v14, i_v23); // 0x11154
        i_v12 = i_v21 + 0xffff;
        i_v13--;
        if (p_v24 == NULL) {
            // 0x11168
            printf("cgminer realloc: OOM (%d)\n", i_v23);
            return 1;
        }
        p_v14 = p_v24;
        i_v15 = i_v21;
        i_v16 = (int32_t)p_v14;
        i_v17 = i_v15 + i_v16;
        i_v18 = recv(i_v2, (int32_t *)i_v17, 0xffff, 0);
    }
    // 0x111d4
    printf("Recv failed: %s\n", strerror(*__errno_location()));
    i_v19 = 1;
    i_v20 = i_v17;
    goto lab_0x1119c;
lab_0x1119c:
    // 0x1119c
    *(char *)i_v20 = 0;
    if (i_g5 == 0) {
        // 0x111cc
        display(i_v16);
    } else {
        // 0x111bc
        puts((char *)p_v14);
    }
    // 0x111c0
    free(p_v14);
    // 0x10fc0
    close(i_v2);
    // 0x10fc8
    return i_v19;
}

// Address range: 0x11214 - 0x11248
int32_t __libc_csu_init(int32_t i_a1, int32_t i_a2, int32_t i_a3,
                        int32_t i_a4) {
    int32_t i_v1 = _init(i_a1, i_a2, i_a3, i_a4); // 0x11224
    return 0x21f0a - (int32_t)&i_g3 >> 2 == 0 ? i_v1 : i_a1;
}

// Address range: 0x11250 - 0x11252
int32_t __libc_csu_fini(void) {
    // 0x11250
    int32_t i_v1; // 0x11250
    return i_v1;
}

// Address range: 0x11254 - 0x1125c
int32_t _fini(int32_t i_a1, int32_t i_a2, int32_t i_a3, int32_t i_a4) {
    // 0x11254
    return i_a1;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.3)
// Detected functions: 38
